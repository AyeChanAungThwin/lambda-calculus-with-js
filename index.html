<!DOCTYPE html>
<html>

<head>
    <title>Lambda Calculus</title>
    <link rel="stylesheet" href="css/style.css">
    <script defer src="js/animation.js"></script>
    <script defer src="js/lambda-calculus-with-js.js"></script>
</head>

<body>
    <section class="container title-design">
        <h2 class="main-title"><span>L</span>.<span>a</span>.<span>m</span>.<span>b</span>.<span>d</span>.<span>a</span>
            Calculus</h2>
        <h4 class="main-subtitle">The Origin of Functional Programming</h4>
    </section>

    <section class="container what-and-why">
        <h3 class="title">Abstraction: What and Why?</h3>
        <p>
            Everything can be expressed as a function. But it shouldn't be used everywhere. Once it is populated with
            arguments, its state cannot be changed. Therefore, you have to create another function if you ever once to
            use the same function again. That creates more memory consumption. But the functional paradigm becomes
            popular again because it gives good readability abstracted in a short code. There's also enough memory to
            execute them nowadays.
        </p>

        <p>
            This is the lower-level perspective of a programming language. You can say, "semantics of the functional
            programming." So, you need to be an expert in one of the high-level programming languages. And you also need
            to be a good problem solver. Otherwise, this is just wasting your time!
        </p>

        <p>
            Now, you know what and why. And we're a bit behind the schedule. So, let's start learning it right now!
        </p>
    </section>

    <section class="container what-is-a-function">
        <h3 class="title">What is a function?</h3>
        <p>A function is a black box where you can't see what's inside. If you wanna know if two functions do the same
            thing, you have to put something in it and see if they give us the same result. Let's say there are two
            functions; <span class="equation">f(x)=2x</span>, and <span class="equation">g(x)=x+x</span>, you can't know
            if f(x) is equal g(x) without putting a value in it. This is called <span class="fyi">Extensional Equality</span>.</p>
        <p><span class="equation">f(x)=2x</span>, <span class="equation">f(2)=2*2=4</span></p>
        <p><span class="equation">g(x)=x+x</span>, <span class="equation">g(2)=2+2=4</span></p>
        <p>Hence, <span class="equation">f(2)</span> is equal to <span class="equation">g(2)</span>.</p>
    </section>

    <section class="container birds">
        <h3 class="title">Birds</h3>
        <p>We represent a function with a bird. Each bird is a function. Each function can have one or more functions or
            arguments inside it and we called them layers.</p>
        <p>Half-circle on the left of the box represents a bird's ear and the right one represents its throat. The
            dotted box encloses the red solid line and one box represents one layer. The solid line is a pipe which
            shows
            the direction of
            flow the information from ear to throat. Normally, it goes from left to right. We don't use arrow head
            except to indicate reverse flow. <span class="fyi">FYI, ear to the throat is connected through a tube! The
                Eustachian tube is a small passageway that connects your throat to your middle ear.</span></p>

        <div class="animation-container">
            <div class="screen">
                <div class="bird sample">
                    <div class="bird-name code">Bird</div>
                    <div class="pipe">
                        <div class="left-pipe"></div>
                        <div class="mid-pipe"></div>
                        <div class="right-pipe"></div>
                    </div>
                    <h3 class="input sample-input-1 code">ear</h3>
                    <h3 class="input sample-input-2 code">throat</h3>
                </div>
            </div>
        </div>
        </div>
    </section>

    <section class="container function">
        <h3 class="title">Idiot</h3>
        <p>This is the one layer bird. It takes only one argument and return it. It seems to have no intelligence at
            all. That's why we called it, "Idiot" or "Identity." And we present it with "I."
        </p>

        <div class="animation-container">
            <div class="screen">
                <div class="bird idiot">
                    <div class="bird-name code">I</div>
                    <div class="pipe">
                        <div class="left-pipe"></div>
                        <div class="mid-pipe"></div>
                        <div class="right-pipe"></div>
                    </div>
                    <h3 class="input idiot-input code">a</h3>
                </div>
            </div>
        </div>
        <p>Just like <span class="equation">f(x)=x</span>, this one is <span class="equation">I(a)=a</span>. <span
                class="equation">I</span> is a function that takes <span class="equation">a</span> as an argument and
            returns <span class="equation">a</span>. It takes one argument and so Idiot is one-layered bird. You can try
            it, with the syntax of JavaScript's arrow function in console of a browser.
        </p>
        <p class="code">let I = a => a;</p>
        <p class="code">I(0) <span class="comment">//returns 0.</span></p>
        <p class="code">I(1) <span class="comment">//returns 1.</span></p>
        <p>

        </p>
    </section>

    <section class="container function">
        <h3 class="title">Kestrel</h3>
        <p>It is the two layer bird. It takes two arguments and return the first one. If you put 1 and then 2, it will
            only return 1. because the second argument has no connection from ear to throat. <span class="fyi">Note that
                pipes can be passed freely from outter box to inner box without having to pass through inner box's
                ear.</span></p>

        <div class="animation-container">
            <div class="screen">
                <div class="bird kestrel-a">
                    <div class="bird-name kestrel code">K</div>
                    <div class="pipe">
                        <div class="left-pipe"></div>
                        <div class="mid-pipe"></div>
                        <div class="right-pipe"></div>
                    </div>
                    <h3 class="input kestrel-a-input code">a</h3>
                </div>

                <div class="bird kestrel-b">
                    <div class="pipe">
                        <div class="left-pipe"></div>
                        <div class="mid-pipe"></div>
                        <div class="right-pipe"></div>
                    </div>
                    <h3 class="input kestrel-b-input code">b</h3>
                </div>
            </div>
        </div>

        <p>You can try it, with the syntax of JavaScript's arrow function in console of a browser.
        <pre class="comment">
        let K = function(a) {
            return function(b) {
                return a;
            }
        }</pre>
        </p>
        <p class="code">let K = a => b => a;</p>
        <p class="code">K(0)(1) <span class="comment">//will return 0.</span></p>
        <p class="code">K(1)(2) <span class="comment">//will return 1.</span></p>
        <p>As you can see, Kestrel always return the first thing and so you can neglect the second one. Kestrel can be
            used as a constant. For example, <span class="equation">K(3)</span> will always gives you back <span
                class="equation">3</span> regardless of the second one. That's called the constant. And we can create like this.</p>
        <p class="code">
            let K3 = K(3);
        </p>
        <p class="code">
            K3(0) <span class="comment">//returns 3.</span>
        </p>
        <p class="code">
            K3(1) <span class="comment">//returns 3.</span>
        </p>
        <p>Forget about its syntax and look at the sequence that executes. Does it look familiar to you?</p>
    </section>

    <section class="container function">
        <h3 class="title">True/False Function</h3>
        <p>In the ternary operation of the high-level syntax, it will be like the following...</p>
        <p class="code">boolean?value1:value2;</p>
        <p>If <span class="equation">boolean</span> is true, it returns the first one; <span
                class="equation">value1</span>. So, <span class="equation">Kestrel</span> is the <span
                class="equation">TRUE function</span>. So, what's the <span class="equation">FALSE function</span>? It
            returns the second thing. Now, you get both TRUE and FALSE functions.</p>
        <p class="code">let T = K;</p>
        <p>Now, you can create the FALSE function like the following.</p>
        <p class="code">let F = a => b => b;</p>
        <p>But instead of manually creating a new function like the above, you can combine existing functions to create
            a new one that gives us a new function.</p>
    </section>

    <section class="container function">
        <h3 class="title">Kite</h3>
        <p>What do we get if Kestrel heard an Idiot song? <span class="equation">K</span> will give us the first one and
            so we just note the second one with <span class="equation">x</span>.</p>
        <p class="equation">K(I)(x) = I</p>
        <p>When we put <span class="equation">Idiot</span> as the first argument to <span
                class="equation">Kestrel</span>, we will get an <span class="equation">Idiot</span> because it returns
            the first thing. But <span class="equation">Idiot</span> can take one argument.</p>
        <p class="equation">K(I)(x)(y) = I(y) = y</p>
        <p>The <span class="equation">K function</span> itself can take one argument but when it combines with another
            function, it becomes a new function and can take THREE arguments. But we don't use it like that. We combine
            the two functions and create a new function. Only after that, we use it with arguments.</p>
        <div class="animation-container">
            <div class="screen">
                <div class="bird kestrel1-a">
                    <div class="bird-name kestrel1-a code">K</div>
                    <div class="pipe">
                        <div class="left-pipe"></div>
                        <div class="mid-pipe"></div>
                        <div class="right-pipe"></div>
                    </div>

                    <div class="bird idiot1 input kestrel1-a-input">
                        <div class="bird-name idiot1 code">I</div>
                        <div class="pipe">
                            <div class="left-pipe"></div>
                            <div class="mid-pipe"></div>
                            <div class="right-pipe"></div>
                        </div>
                    </div>
                </div>

                <div class="bird kestrel1-b">
                    <div class="bird-name kite-demo code"></div>
                    <div class="pipe">
                        <div class="left-pipe"></div>
                        <div class="mid-pipe"></div>
                        <div class="right-pipe"></div>
                    </div>
                    <!-- <h3 class="input kestrel1-b-input code">b</h3> -->
                </div>
            </div>
        </div>

        <p>When an input is a function, it breaks the layer of a bird once the input function's throat hits the ear of
            the bird. And the input function will go until its throat touches the end of the innermost layer's throat.
            But the input function will never get out of the innermost layer's throat. Only the argument gets out of the
            throat.</p>

        <div class="animation-container">
            <div class="screen">
                <div class="bird kite-a">
                    <div class="bird-name kite-a code">KI</div>
                    <div class="pipe">
                        <div class="left-pipe"></div>
                        <div class="mid-pipe"></div>
                        <div class="right-pipe"></div>
                    </div>
                    <h3 class="input kite-a-input code">a</h3>
                </div>

                <div class="bird kite-b">
                    <div class="pipe">
                        <div class="left-pipe"></div>
                        <div class="mid-pipe"></div>
                        <div class="right-pipe"></div>
                    </div>
                    <h3 class="input kite-b-input code">b</h3>
                </div>
            </div>
        </div>
        <p class="code">let KI = K(I); <span class="comment">//new func.</span></p>
        <p class="code">KI(1)(2) <span class="comment">//returns 2.</span></p>
        <p>So, the <span class="equation">KI</span> function returns the second one. So, it's a <span
                class="equation">FALSE</span> function. As I mentioned above, sometimes, we don't need to create another
            function, we can combine existing functions to create a new one. Let's reassign <span
                class="equation">F</span> with <span class="equation">KI</span>.</p>
        <p class="code">F = KI;</p>
    </section>

    <section class="container function">
        <h3 class="title">Creating toBoolean Function</h3>
        <p>
            When we check <span class="equation">T</span> in the console, It will give back <span class="equation">K(a)</span> that returns the first thing. It will only return the function because we didn't put some arguments. So, we are going to make it readable in the syntax of JavaScript.
        </p>
        <p class="code">let toBoolean = f => f(true)(false);</p>
        <p>
            <span class="equation">toBoolean function</span> takes a function and applies two arguments; true and false. If the function is <span class="equation">K</span>, it will return the first one i.e., true.
        </p>
        <p class="code">toBoolean(K) <span class="comment">//returns true.</span></p>
        <p class="code">toBoolean(KI) <span class="comment">//returns false.</span></p>
        <p>
            Remember that <span class="equation">K</span> is assigned to <span class="equation">T</span> and <span class="equation">KI</span> is assigned to <span class="equation">F</span>.
        </p>
        <p class="code">toBoolean(T) <span class="comment">//returns true.</span></p>
        <p class="code">toBoolean(F) <span class="comment">//returns false.</span></p>
        <p class="fyi">
            Don't lose the point. Functional Programming expresses everything with a function. We're just created "toBoolean function" only to check if it works in high-level perspective.
        </p>
    </section>

    <section class="container function">
        <h3 class="title">Cardinal</h3>
        <p>This is the three layer bird. It takes a function with two arguments and flip them. I assume you understand
            how the bird works and I won't use animation schema so that I could speed this up.
        </p>
        <p class="code">let C = f => a => b => f(b)(a);</p>
        <p class="code">C(K)(1)(2) <span class="comment">//returns 2.</span></p>
        <p class="code">C(KI)(1)(2) <span class="comment">//returns 1.</span></p>
        <p>
            So, it just swap two arguments of a function. <span class="equation">K</span> gives the second one and <span
                class="equation">KI</span> gives the first one now. <span class="equation">K</span> becomes <span
                class="equation">KI</span> and <span class="equation">KI</span> becomes <span class="equation">K</span>.
        </p>
        <p class="code">
            C(K)(1)(2) == KI(1)(2)
        </p>
        <p class="code">
            C(KI)(1)(2) == K(1)(2)
        </p>
        <p>That's how the functions meet extensional equality. <span class="equation">Cardinal</span> reverses the <span class="equation">True</span> and <span class="equation">False</span> functions. So, <span class="equation">Cardinal</span> is just a <span class="equation">NOT</span> function.</p>
    </section>

    <section class="container function">
        <h3 class="title">NOT function</h3>
        <p class="code">
            let NOT = C;
        </p>
        <p class="code">
            NOT(T)<span class="comment">//returns C(a)</span>
        </p>
        <p class="code">
            NOT(F)<span class="comment">//returns C(a)</span>
        </p>
        <p>Sometimes, the result doesn't seem to be clear like this. We need to put some values and check it.</p>
        <p class="code">
            NOT(T)(true)(false) <span class="comment">//returns false.</span>
        </p>
        <p class="code">
            NOT(F)(true)(false) <span class="comment">//returns true.</span>
        </p>
        <p>
            Instead of checking the result like this from above, it would be better in readability if we use some function like the following.
        </p>
        <p class="code">
            toBoolean(NOT(T)) <span class="comment">//returns false.</span>
        </p>
        <p class="code">
            toBoolean(NOT(F)) <span class="comment">//returns true.</span>
        </p>
        <p>
            That's why we should to use some sophisticated functions to check the result.
        </p>
    </section>

    <section class="container function">
        <h3 class="title">AND function</h3>
        <p>How does it work? If all are <span class="equation">TRUE</span>, returns <span class="equation">TRUE</span>. If one of them is <span class="equation">FALSE</span>, returns <span class="equation">FALSE</span>.</p>

        <p class="fyi">let AND = p => q => p??</p>
        <p>If p is true, we know p is K. K will return the first thing. So, we just need to check the other one. So, we know what to return. It is q.</p>

        <p class="fyi">let AND = p => q => p(q)?</p>
        <p>If p is false, we know p is KI. KI will return the second thing. One of them is false, then returns false.</p>

        <p class="fyi">let AND = p => q => p(q)(F);</p>
        <p>Or we can simplify it and return p that is already false.</p>

        <p class="code">let AND = p => q => p(q)(p);</p>

        <p>Note: T = K and F = KI.</p>
        <p class="fyi">AND(p)(q) = p(q)(p)</p>
        <p class="fyi">AND(F)(F) = F(F)(F) = KI(KI)(KI) = KI = F</p>
        <p class="fyi">AND(F)(T) = F(T)(F) = KI(K)(KI) = KI = F</p>
        <p class="fyi">AND(T)(F) = T(F)(T) = K(KI)(K) = KI = F</p>
        <p class="fyi">AND(T)(T) = T(T)(T) = K(K)(K) = K = T</p>

        <p class="code">AND(F)(F)</p>
        <p class="code">AND(F)(T)</p>
        <p class="code">AND(T)(F)</p>
        <p class="code">AND(T)(T)</p>

        <p>Those codes above will only returns a function. And so, we will have to use <span class="equation">toBoolean Function</span> to check the result.</p>

        <p class="code">
            toBoolean(AND(F)(F))
        </p>
        <p class="code">
            toBoolean(AND(F)(T))
        </p>
        <p class="code">
            toBoolean(AND(T)(F))
        </p>
        <p class="code">
            toBoolean(AND(T)(T))
        </p>
    </section>
</body>

</html>